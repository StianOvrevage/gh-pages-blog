<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Databases on blog.stian.omg.lol</title><link>https://blog.stian.omg.lol/tags/databases/</link><description>Recent content in Databases on blog.stian.omg.lol</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 06 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.stian.omg.lol/tags/databases/index.xml" rel="self" type="application/rss+xml"/><item><title>A side quest in API development, observability, Kubernetes and cloud with a hint of database</title><link>https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/</link><pubDate>Sat, 06 Mar 2021 00:00:00 +0000</pubDate><guid>https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/</guid><description>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2021-03-06-a-side-quest-in-api-dev-operations-cloud-and-database.png" alt="Featured image of post A side quest in API development, observability, Kubernetes and cloud with a hint of database" />&lt;p>Quite often people ask me what I actually do. I have a hard time giving a short answer. Even to colleagues and friends in the industry.&lt;/p>
&lt;p>Here I will try to show and tell how I spent an evening digging around in a system I helped build for a client.&lt;/p>
&lt;br>
&lt;hr>
&lt;br>
&lt;p>&lt;strong>Table of contents&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="#Background" >Background&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#TheProblem" >The (initial) problem&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#FurtherReading" >Fixing the (initial) problem&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#FurtherReading" >Verifying the (initial) fix&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#FurtherReading" >Baseline simple request - HTTP1 1 connections, 20000 requests&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#FurtherReading" >Baseline complex request - HTTP1 1 connections, 20000 requests&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#FurtherReading" >Verifying the fix for assumed workload&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#FurtherReading" >Complex request - HTTP1 6 connections, 500 requests&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#FurtherReading" >Complex request - HTTP2 500 &amp;ldquo;connections&amp;rdquo;, 500 requests&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#FurtherReading" >Side quest: Database optimizations&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#FurtherReading" >Determining the next bottleneck&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#FurtherReading" >Side quest: Cluster resources and burstable VMs&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#Conclusion" >Conclusion&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a id="Background">&lt;/a>&lt;/p>
&lt;h1 id="background">Background
&lt;/h1>&lt;p>I&amp;rsquo;m a consultant doing development, DevOps and cloud infrastructure.&lt;/p>
&lt;p>For this specific client I mainly develop APIs using Golang to support new products and features as well as various exporting, importing and processing of data in the background.&lt;/p>
&lt;p>I&amp;rsquo;m also the &amp;ldquo;ops&amp;rdquo; guy handling everything in AWS, setting up and maintaing databases, making sure the &amp;ldquo;DevOps&amp;rdquo; works and the frontend and analytics people can do their work with little friction.
99% of the time things work just fine. No data is lost. The systems very rarely have unforeseen downtime and the users can access the data they want with acceptable latency rarely exceeding 500ms.&lt;/p>
&lt;p>A couple of times a year I assess the status of the architecture and set up new environments from scratch and update any documentation that has drifted. This is also a good time to do changes and add or remove constraints in anticipation of future business needs.&lt;/p>
&lt;p>In short, the current tech stack that has evolved over a couple of years is:&lt;/p>
&lt;ul>
&lt;li>Everything hosted on Amazon Web Services (AWS).&lt;/li>
&lt;li>AWS managed Elastic Kubernetes Service (EKS) currently on K8s 1.18.&lt;/li>
&lt;li>GitHub Actions for building Docker images for frontends, backends and other systems.&lt;/li>
&lt;li>AWS Elastic Container Registry for storing Docker images.&lt;/li>
&lt;li>Deployment of each system defined as a Helm chart alongside source code.&lt;/li>
&lt;li>Actual environment configuration (Helm values) stored in repo along source code. Updated by GitHub Actions.&lt;/li>
&lt;li>ArgoCD in cluster to manage status of all environments and deployments. Development environments usually automatically deployed on change. Push a button to deploy to Production.&lt;/li>
&lt;li>Prometheus for storing metrics from the cluster and nodes itself as well as custom metrics for our own systems.&lt;/li>
&lt;li>Loki for storing logs. Makes it easier to retrieve logs from past Pods and aggregate across multiple Pods.&lt;/li>
&lt;li>Elastic APM server for tracing.&lt;/li>
&lt;li>Pyroscope for live CPU profiling/tracing of Go applications.&lt;/li>
&lt;li>Betteruptime.com for tracking uptime and hosting status pages.&lt;/li>
&lt;/ul>
&lt;p>I might write up a longer post about the details if anyone is interested.&lt;/p>
&lt;p>&lt;a id="TheProblem">&lt;/a>&lt;/p>
&lt;h1 id="the-initial-problem">The (initial) problem
&lt;/h1>&lt;p>A week ago I upgraded our API from version 1, that was deployed in January, to version 2 with new features and better architecture.&lt;/p>
&lt;p>One of the endpoints of the API returns an analysis of an object we track. I have previously reduced the amount of database queries by 90% but it still requires about 50 database calls from three different databases.
Getting and analyzing the data usually completes in about 3-400 milliseconds returning an 11.000 line JSON.&lt;/p>
&lt;p>It&amp;rsquo;s also possible to just call &lt;code>/objects/analysis&lt;/code> to get the analysis for all the 500 objects we are tracking. It takes 20 seconds but is meant for exports to other processes and not interactive use, so not a problem.&lt;/p>
&lt;p>Since the product is under very active development the frontend guys just download the whole analysis for an object to show certain relevant information to users. It&amp;rsquo;s too early to decide on which information is needed more often and how to optimize for that. Not a problem.&lt;/p>
&lt;p>So we need an overview of some fields from multiple objects in a dashboard / list. We can easily pull analysis from 20 objects without any noticable delay.&lt;/p>
&lt;p>But what if we just want to show more, 50? 200? 500? The frontend already have the IDs for all the objects and fetches them from &lt;code>/objects/id/analysis&lt;/code>. So they loop over the IDs and fire of requests simultaneously.&lt;/p>
&lt;p>Analyzing the network waterfall in Chrome DevTools indicated that the requests now took 20-30 seconds to complete! But looking closer most of the time they were actually queued up in the browser. This is because
Chrome only allows 6 concurrent TCP connection to the same origin when using HTTP1 (&lt;a class="link" href="https://developers.google.com/web/tools/chrome-devtools/network/understanding-resource-timing%29" target="_blank" rel="noopener"
>https://developers.google.com/web/tools/chrome-devtools/network/understanding-resource-timing)&lt;/a>.&lt;/p>
&lt;p>&lt;a id="TheProblem">&lt;/a>&lt;/p>
&lt;h2 id="fixing-the-initial-problem">Fixing the (initial) problem
&lt;/h2>&lt;p>HTTP2 should fix this problem easily. By default HTTP2 is disabled in nginx-ingress. I add a couple of lines enabling it and update the Helm deployment of the ingress controller.&lt;/p>
&lt;p>&lt;a id="TheProblem">&lt;/a>&lt;/p>
&lt;h2 id="verifying-the-initial-fix">Verifying the (initial) fix
&lt;/h2>&lt;p>Some common development tools doesn&amp;rsquo;t support HTTP2, such as Postman. So I found &lt;code>h2load&lt;/code> which can both help me verify HTTP2 is working and I also get to measure the improvement, nice!&lt;/p>
&lt;blockquote>
&lt;p>Note that I&amp;rsquo;m not using the analysis endpoint since I want to measure the change from HTTP1 to HTTP2 and it will become apparent later that there are other bottlenecks preventing us from a linear performance increase when just changing from HTTP1 to HTTP2.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Also note that this is somewhat naive since it requests the same URL over and over which can give false results due to any caching. But fortunately we don&amp;rsquo;t do any caching yet.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a id="TheProblem">&lt;/a>&lt;/p>
&lt;h3 id="baseline-simple-request---http1-1-connections-20000-requests">Baseline simple request - HTTP1 1 connections, 20000 requests
&lt;/h3>&lt;p>Using 1 concurrent streams, 1 client and HTTP1 I get an estimate of performance pre-http2:&lt;/p>
&lt;pre>&lt;code>h2load --h1 --requests=20000 --clients=1 --max-concurrent-streams=1 https://api.x.com/api/v1/objects/1
&lt;/code>&lt;/pre>
&lt;p>The results are as expected:&lt;/p>
&lt;pre>&lt;code>finished in 1138.99s, 17.56 req/s, 18.41KB/s
requests: 20000 total, 20000 started, 20000 done, 19995 succeeded, 5 failed, 0 errored, 0 timeout
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-apm.png"
width="1816"
height="705"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-apm_hu17076544040877865054.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-apm_hu9690961613720477067.png 1024w"
loading="lazy"
alt="Overview from Elastic APM. Duration is very acceptable at around 20ms. No errors. And about 25% of the time spent doing database queries."
class="gallery-image"
data-flex-grow="257"
data-flex-basis="618px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-cpu.png"
width="1034"
height="314"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-cpu_hu2013984859425220242.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-cpu_hu13236457479005124721.png 1024w"
loading="lazy"
alt="Container CPU usage. Nothing special."
class="gallery-image"
data-flex-grow="329"
data-flex-basis="790px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-db-latency.png"
width="861"
height="356"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-db-latency_hu1867474644236441644.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-db-latency_hu15523458481306920119.png 1024w"
loading="lazy"
alt="Database query latency. The vast majority under 5ms. Acceptable."
class="gallery-image"
data-flex-grow="241"
data-flex-basis="580px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-db-queries.png"
width="780"
height="348"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-db-queries_hu17361066750422420350.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-db-queries_hu10420784785634132053.png 1024w"
loading="lazy"
alt="Number of DB queries per second."
class="gallery-image"
data-flex-grow="224"
data-flex-basis="537px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-http-latency.png"
width="863"
height="316"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-http-latency_hu6805455395055610702.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-http-latency_hu3298924550317512719.png 1024w"
loading="lazy"
alt="HTTP response latency."
class="gallery-image"
data-flex-grow="273"
data-flex-basis="655px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-http-requests.png"
width="778"
height="217"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-http-requests_hu5945712598158928612.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/0-baseline-http1-1-concurrent-http-requests_hu419352892190289981.png 1024w"
loading="lazy"
alt="Number of HTTP requests per second. Unsurprisingly the number of database queries are identical to the number of HTTP requests. Latency of HTTP requests also tracks the latency of the (single) database query."
class="gallery-image"
data-flex-grow="358"
data-flex-basis="860px"
>&lt;/p>
&lt;p>For http2 we set max concurrent streams to the same as number of requests:&lt;/p>
&lt;pre>&lt;code>h2load --requests=200 --clients=1 --max-concurrent-streams=200 https://api.x.com/api/v1/objects/1
&lt;/code>&lt;/pre>
&lt;p>Which results in almost half the latency:&lt;/p>
&lt;pre>&lt;code>finished in 1.23s, 162.65 req/s, 158.06KB/s
requests: 200 total, 200 started, 200 done, 200 succeeded, 0 failed, 0 errored, 0 timeout
&lt;/code>&lt;/pre>
&lt;p>So HTTP2 is working and providing significant latency improvements. Success!&lt;/p>
&lt;p>&lt;a id="TheProblem">&lt;/a>&lt;/p>
&lt;h3 id="baseline-complex-request---http1-1-connections-20000-requests">Baseline complex request - HTTP1 1 connections, 20000 requests
&lt;/h3>&lt;p>We start by establishing a baseline with 1 connection querying over and over.&lt;/p>
&lt;pre>&lt;code>h2load --h1 --requests=20000 --clients=1 --max-concurrent-streams=1
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-apm.png"
width="2087"
height="707"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-apm_hu13565166093859492250.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-apm_hu14225806095910349646.png 1024w"
loading="lazy"
alt="Latency increases as much more computation is done and data is returned. But the latency is consistent which is good. We also see that the database is becomming the bottleneck for where most time is spent."
class="gallery-image"
data-flex-grow="295"
data-flex-basis="708px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-cpu.png"
width="1200"
height="308"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-cpu_hu4067009256511003722.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-cpu_hu17950687200232907900.png 1024w"
loading="lazy"
alt="CPU usage increased to 15%. Lower increase than expected considering the complexity involved in serving the requests."
class="gallery-image"
data-flex-grow="389"
data-flex-basis="935px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-db-latency.png"
width="985"
height="344"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-db-latency_hu7089278039337102831.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-db-latency_hu17575998733902921949.png 1024w"
loading="lazy"
alt="Database query latency still mostly under 5ms."
class="gallery-image"
data-flex-grow="286"
data-flex-basis="687px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-db-queries.png"
width="894"
height="351"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-db-queries_hu6509951597429203579.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-db-queries_hu14549008744426915283.png 1024w"
loading="lazy"
alt="Number of database queries increases by a factor of 10 compared to HTTP requests."
class="gallery-image"
data-flex-grow="254"
data-flex-basis="611px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-http-latency.png"
width="987"
height="313"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-http-latency_hu565398038381364000.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-http-latency_hu7243746795286387547.png 1024w"
loading="lazy"
alt="HTTP latency."
class="gallery-image"
data-flex-grow="315"
data-flex-basis="756px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-http-requests.png"
width="895"
height="219"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-http-requests_hu9040739607883373017.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/1-baseline-http1-1-concurrent-analysis-http-requests_hu3790465645525383070.png 1024w"
loading="lazy"
alt="HTTP requests per second."
class="gallery-image"
data-flex-grow="408"
data-flex-basis="980px"
>&lt;/p>
&lt;p>&lt;a id="TheProblem">&lt;/a>&lt;/p>
&lt;h2 id="verifying-the-fix-for-assumed-workload">Verifying the fix for assumed workload
&lt;/h2>&lt;p>So we verified that HTTP2 gives us a performance boost. But what happens when we fire away 500 requests to the much heavier &lt;code>/analysis&lt;/code> endpoint?&lt;/p>
&lt;blockquote>
&lt;p>These graphs are not as pretty since the ones above. This is mainly due to the sampling interval of the metrics and that we need several datapoints to accurately determine the rate() of a counter.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a id="TheProblem">&lt;/a>&lt;/p>
&lt;h3 id="complex-request---http1-6-connections-500-requests">Complex request - HTTP1 6 connections, 500 requests
&lt;/h3>&lt;pre>&lt;code>finished in 32.25s, 14.88 req/s, 2.29MB/s
requests: 500 total, 500 started, 500 done, 500 succeeded, 0 failed, 0 errored, 0 timeout
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-apm.png"
width="1484"
height="705"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-apm_hu2573287072721533229.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-apm_hu10620414983979950514.png 1024w"
loading="lazy"
alt="2-burst-http1-6-concurrent-analysis-apm"
class="gallery-image"
data-flex-grow="210"
data-flex-basis="505px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-cpu.png"
width="847"
height="299"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-cpu_hu1135877464954207689.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-cpu_hu17008451797633252465.png 1024w"
loading="lazy"
alt="2-burst-http1-6-concurrent-analysis-cpu"
class="gallery-image"
data-flex-grow="283"
data-flex-basis="679px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-db-latency.png"
width="706"
height="359"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-db-latency_hu9358974391483687749.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-db-latency_hu16352819740947538611.png 1024w"
loading="lazy"
alt="2-burst-http1-6-concurrent-analysis-db-latency"
class="gallery-image"
data-flex-grow="196"
data-flex-basis="471px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-db-queries.png"
width="637"
height="352"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-db-queries_hu17797633323803646239.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-db-queries_hu2207066698060964218.png 1024w"
loading="lazy"
alt="2-burst-http1-6-concurrent-analysis-db-queries"
class="gallery-image"
data-flex-grow="180"
data-flex-basis="434px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-http-latency.png"
width="700"
height="321"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-http-latency_hu13253021454442065078.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-http-latency_hu13649080090034874975.png 1024w"
loading="lazy"
alt="2-burst-http1-6-concurrent-analysis-http-latency"
class="gallery-image"
data-flex-grow="218"
data-flex-basis="523px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-http-requests.png"
width="638"
height="213"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-http-requests_hu12544065771888019895.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/2-burst-http1-6-concurrent-analysis-http-requests_hu1798439057131787658.png 1024w"
loading="lazy"
alt="2-burst-http1-6-concurrent-analysis-http-requests"
class="gallery-image"
data-flex-grow="299"
data-flex-basis="718px"
>&lt;/p>
&lt;p>In summary it so far seems to scale linearly with load. Most of the time is spent fetching data from the database. Still very predictable low latency on database queries and the resulting HTTP response.&lt;/p>
&lt;p>&lt;a id="TheProblem">&lt;/a>&lt;/p>
&lt;h3 id="complex-request---http2-500-connections-500-requests">Complex request - HTTP2 500 &amp;ldquo;connections&amp;rdquo;, 500 requests
&lt;/h3>&lt;p>&lt;em>So now we unleash the beast. Firing all 500 requests at the same time.&lt;/em>&lt;/p>
&lt;pre>&lt;code>finished in 16.66s, 30.02 req/s, 3.55MB/s
requests: 500 total, 500 started, 500 done, 500 succeeded, 0 failed, 0 errored, 0 timeout
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-cpu.png"
width="939"
height="307"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-cpu_hu5828488102210360607.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-cpu_hu3343570902582545481.png 1024w"
loading="lazy"
alt="CPU on API still doing good. A slight hint of CPU throttling due to CFS, which is used when you set CPU limits in Kubernetes."
class="gallery-image"
data-flex-grow="305"
data-flex-basis="734px"
>&lt;/p>
&lt;blockquote>
&lt;p>Important about Kubernetes and CPU limits&lt;br />
Even with CPU limits set to 1 (100% of one CPU), your container can still be throttled at much lower CPU usage. Check out &lt;a class="link" href="https://medium.com/omio-engineering/cpu-limits-and-aggressive-throttling-in-kubernetes-c5b20bd8a718" target="_blank" rel="noopener"
>this article&lt;/a> for more information.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-db-latency.png"
width="782"
height="346"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-db-latency_hu16596262103242219393.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-db-latency_hu6743393326456624241.png 1024w"
loading="lazy"
alt="Whopsie. The average database query latency has increased drastically, and we have a long tail of very slow queries. Looks like we are starting to see signs of bottlenecks on the database. This might also be affected by our maximum of 60 concurrent connections to the database, resulting in queries having to wait their turn before executing."
class="gallery-image"
data-flex-grow="226"
data-flex-basis="542px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-db-queries.png"
width="705"
height="346"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-db-queries_hu17270843372303526721.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-db-queries_hu14745640312772792195.png 1024w"
loading="lazy"
alt="Its hard to judge the peak rate of database queries due to limited sampling of the metrics."
class="gallery-image"
data-flex-grow="203"
data-flex-basis="489px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-http-latency.png"
width="783"
height="309"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-http-latency_hu9429010041105922198.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-http-latency_hu14677623071583589615.png 1024w"
loading="lazy"
alt="Now individual HTTP requests are much slower due to waiting for the database."
class="gallery-image"
data-flex-grow="253"
data-flex-basis="608px"
>&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-apm-trace.png"
width="1150"
height="1192"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-apm-trace_hu12116834356231894546.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/3-burst-http2-500-concurrent-analysis-apm-trace_hu17401424198592652531.png 1024w"
loading="lazy"
alt="Here is just a random trace from Elastic APM to see if the increased database latency is concentrated to specific queries or tables or just general saturation. Indeed there is a single query responsible for half the time taken for the entire query! We better get back to that in a bit and dig further."
class="gallery-image"
data-flex-grow="96"
data-flex-basis="231px"
>&lt;/p>
&lt;p>In an ideal world all 500 requests should start and complete in 2-300ms regardless. Since that is not happening it&amp;rsquo;s an indication that we are now hitting some other bottleneck.&lt;/p>
&lt;p>Looking at the graphs it seems we are starting to saturate the database. The latency for every request is now largely dependent on the slowest of the 10-12 database queries it depends on. And as we are stressing the database the probability of slow queries increase. The latency for the whole process of fetching 500 requests are again largely dependent on the slowest requests.&lt;/p>
&lt;p>So this optimization gives on average better performance, but more variability of the individual requests, when the system is under heavy load.&lt;/p>
&lt;p>&lt;a id="TheProblem">&lt;/a>&lt;/p>
&lt;h1 id="side-quest-database-optimizations">Side quest: Database optimizations
&lt;/h1>&lt;p>It seems we are saturating the database. Before throwing more money at the problem (by increasing database size) I like to know what the bottlenecks are. Looking at the traces from APM
I see one query that is consistently taking 10x longer than the rest. I also confirm this in the AWS RDS Performance Insights that show the top SQL queries by load.&lt;/p>
&lt;p>When designing the database schema I came up with the idea of having immutability for certain data types. So instead of overwriting row with ID 1, we add a row with ID 1 Revision 2. Now we have the history of who did what to the data and can easily track changes and roll back if needed. The most common use case is just fetching the last revision. So for simplicity I created a PostgreSQL view that only shows the last revision. That way clients don&amp;rsquo;t have to worry about the existense of revisions at all. That is now just an implementation detail.&lt;/p>
&lt;p>When it comes to performance that turns out to be an important implementation detail. The view is using &lt;code>SELECT DISTINCT ON (id) ... ORDER BY id, revision DESC&lt;/code>. However many of the queries to the view is ordering the returned data by time, and expect the data returned from database to already be ordered chronologically. Using &lt;code>EXPLAIN ANALYZE&lt;/code> on the queries this always results in a full table scan instead of using indexes, and is what&amp;rsquo;s causing this specific query to be slow. Without going into details it seems there is no simple and efficient way of having a view with the last revision and query that for a subset of rows ordered again by time.&lt;/p>
&lt;p>For the forseable future this does not actually impact real world usage. It&amp;rsquo;s only apparent under artificially large loads under the worst conditions. But now we know where we need to refactor things if performance actually becomes a problem.&lt;/p>
&lt;p>&lt;a id="TheProblem">&lt;/a>&lt;/p>
&lt;h1 id="determining-the-next-bottleneck">Determining the next bottleneck
&lt;/h1>&lt;p>Whenever I fix one problem I like to know where, how and when the next problem or limit is likely to appear. When increasing the number of requests and streams I expected to see increasing latency. But instead I see errors appear like a cliff:&lt;/p>
&lt;pre>&lt;code>finished in 27.33s, 36.59 req/s, 5.64MB/s
requests: 5000 total, 1002 started, 1002 done, 998 succeeded, 4002 failed, 4000 errored, 0 timeout
&lt;/code>&lt;/pre>
&lt;p>Consulting the logs for both the nginx load balancer and the API there are no records of failing requests. Since nginx does not pass the HTTP2 connection directly to the API, but instead &amp;ldquo;unbundles&amp;rdquo; them into HTTP1 requests I suspect there might be issues with connection limits or even available ports from nginx to the API. But maybe it&amp;rsquo;s a configuration issue. By default nginx does &lt;a class="link" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#server" target="_blank" rel="noopener"
>not limit the number of connections to a backend&lt;/a> (our API). . But, there is actually a &lt;a class="link" href="https://nginx.org/en/docs/http/ngx_http_v2_module.html#http2_max_requests" target="_blank" rel="noopener"
>default limit to the number of HTTP2 requests that can be served over a single connection&lt;/a> - And it happens to be 1000.&lt;/p>
&lt;p>I leave it at that. It&amp;rsquo;s very unlikely we&amp;rsquo;ll be hitting these limits any time soon.&lt;/p>
&lt;p>&lt;a id="TheProblem">&lt;/a>&lt;/p>
&lt;h1 id="side-quest-cluster-resources-and-burstable-vms">Side quest: Cluster resources and burstable VMs
&lt;/h1>&lt;p>When load testing the first time around sometimes Grafana would also become unresponsive. That&amp;rsquo;s usually a bad sign. It might indicate that the underlying infrastructure is also reaching saturation. That is not good since it can impact what should be independent services.&lt;/p>
&lt;p>Our Kubernetes cluster is composed of 2x t3a.medium on demand nodes and 2x t3a.medium spot nodes. These VM types are burstable. You can use 20% per vCPU sustained over time without problems. If you exceed those 20% you start consuming CPU credits faster than they are granted and once you run out of CPU credits processes will be forcibly throttled.&lt;/p>
&lt;p>Of course Kubernetes does not know about this and expects 1 CPU to actually be 1 CPU. In addition Kubernetes will decide where to place workloads based on their stated resource requirements and limits, and not their actual resource usage.&lt;/p>
&lt;p>When looking at the actual metrics two of our nodes are indeed out of CPU credits and being throttled. The sum of factors leading to this is:&lt;/p>
&lt;ul>
&lt;li>We have not yet set resource requests and limits making it harder for Kubernetes to intelligently place workloads&lt;/li>
&lt;li>Using burstable nodes having some additional constraints not visible to Kubernetes&lt;/li>
&lt;li>Old deployments laying around consuming unnecessary resources&lt;/li>
&lt;li>Adding costly features without assessing the overall impact&lt;/li>
&lt;/ul>
&lt;p>I have not touched on the last point yet. I started adding &lt;a class="link" href="https://pyroscope.io/" target="_blank" rel="noopener"
>Pyroscope&lt;/a> to our systems since I simply love monitoring All The Things. The documentation does not go into specifics but emphasizes that it&amp;rsquo;s &amp;ldquo;low overhead&amp;rdquo;. Remember that our budget for CPU usage is actually 40% per node, not 200%. The Pyroscope server itself consumes 10-15% CPU which seems fair. But investigating further the Pyroscope agent also consumes 5-6% CPU per instance. This graph shows the CPU usage of a single Pod before and after turning off Pyroscope profiling.&lt;/p>
&lt;p>&lt;img src="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/pyroscope-agent-cpu.png"
width="1029"
height="271"
srcset="https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/pyroscope-agent-cpu_hu15074112692027608241.png 480w, https://blog.stian.omg.lol/p/a-side-quest-in-api-development-observability-kubernetes-and-cloud-with-a-hint-of-database/pyroscope-agent-cpu_hu2516833612973000297.png 1024w"
loading="lazy"
alt="pyroscope-agent-cpu"
class="gallery-image"
data-flex-grow="379"
data-flex-basis="911px"
>&lt;/p>
&lt;p>5-6% CPU overhead on a highly utilized service is probably worth it. But when the baseline CPU usage is 0% CPU and we have multiple services and deployments in different environments we are suddenly using 40-60% CPU on profiling and less than 1% on actual work!&lt;/p>
&lt;p>The outcome of this is that we need to separate burstable and stable load deployments. Monitoring and supporting systems are usually more stable resource wise while the actual business systems much more variable, and suitable for burst nodes. In practice we add a node pool of non-burst VMs and use NodeAffinity to stick Prometheus, Pyroscope etc to those nodes. Another benefit of this is that the supporting systems needed to troubleshoot problems are now less likely to be impacted by the problem itself, making troubleshooting much easier.&lt;/p>
&lt;p>&lt;a id="Conclusion">&lt;/a>&lt;/p>
&lt;h1 id="conclusion">Conclusion
&lt;/h1>&lt;p>This whole adventure only took a few hours but resulted in some specific and immediate performance gains. It also highlighted the weakest links in our application, database and infrastructure architecture.&lt;/p></description></item><item><title>End of 2020 rough database landscape</title><link>https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/</link><pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate><guid>https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/</guid><description>&lt;img src="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/2020-11-27-end-of-2020-rough-database-landscape.png" alt="Featured image of post End of 2020 rough database landscape" />&lt;p>There seems to exist a database for every niche, mood or emotion. And they seem to change just as fast.&lt;/p>
&lt;p>How do you balance the urge for the new and shiny but without risking too much headache down the road?&lt;/p>
&lt;p>This post is an attempt to lay out the rough landscape of databases that you might encounter or consider as of late 2020.&lt;/p>
&lt;p>There will be broad generalizations for brevity.&lt;/p>
&lt;p>The goal is not to be exhaustive or take all possible precautions. Consider it a starting point for further research and planning.&lt;/p>
&lt;hr>
&lt;p>TLDR: Scroll to the &lt;a class="link" href="#Landscape" >diagrams&lt;/a> or view the &lt;a class="link" href="https://blog.stian.omg.lol/attachments/2020-11-27-end-of-2020-rough-database-landscape/map-complete.png" >big picture&lt;/a>.&lt;/p>
&lt;p>&lt;strong>Table of contents&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="#Background" >Background&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#ProjectPhase" >Project phase overview&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#Planning" >Planning&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#DatabaseCategories" >Database categories&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#SQL" >SQL&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#NoSQL" >NoSQL&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#KeyValue" >KeyValue&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#Timeseries" >Timeseries&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#Graph" >Graph&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#OtherNiceThings" >Other nice things&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#Landscape" >The Landscape&lt;/a>
&lt;ul>
&lt;li>&lt;a class="link" href="#SQLMap" >SQL&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#NoSQLMap" >NoSQL&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#KeyValueMap" >KeyValue&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#TimeseriesMap" >Timeseries&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#GraphMap" >Graph&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a class="link" href="#FurtherReading" >Further reading&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#Conclusion" >Conclusion&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;a id="Background">&lt;/a>&lt;/p>
&lt;h1 id="background">Background
&lt;/h1>&lt;p>I&amp;rsquo;m a consultant doing development, DevOps and cloud infrastructure. I also have the occasional side project trying out the Tech Flavor of the Month.&lt;/p>
&lt;p>&lt;a id="ProjectPhase">&lt;/a>&lt;/p>
&lt;h2 id="project-phase-overview">Project phase overview
&lt;/h2>&lt;p>The typical phases in projects I&amp;rsquo;m involved in follow no scientific or trademarked methodology, so YMMV:&lt;/p>
&lt;h3 id="starting-out">Starting out
&lt;/h3>&lt;p>Get something working as fast as possible. Take all the shortcuts. Use some opinionated framework or platform.&lt;/p>
&lt;h3 id="moving-from-development-to-production">Moving from development to production
&lt;/h3>&lt;p>People like it, people use it. Move the thing from a single &amp;ldquo;pet server&amp;rdquo; to a more robust cloud environment.&lt;/p>
&lt;h3 id="scaling-production">Scaling production
&lt;/h3>&lt;p>Bottlenecks and scaling problems start to emerge. Refactor or replace some pieces to remove the bottlenecks.&lt;/p>
&lt;h3 id="challenges">Challenges
&lt;/h3>&lt;p>Moving between these phases might be a major PITA if the wrong shortcuts were taken in the previous phases.&lt;/p>
&lt;p>&lt;em>This of course applies to all technology choices and not just databases. But we have to start somewhere, right?&lt;/em>&lt;/p>
&lt;p>&lt;a id="Planning">&lt;/a>&lt;/p>
&lt;h1 id="planning">Planning
&lt;/h1>&lt;p>When starting out I try to envision all the phases of the project and which directions it may take in the future.&lt;/p>
&lt;p>First I want the technology or software I choose to be instantly usable. A Docker image. Great. An &lt;code>apt-get install&lt;/code>. Sweet. &lt;code>npm install&lt;/code>. Sure, why not. Downloading a tarball. Installing some C dependencies. Setting some flags. Compiling. Symlinking and fixing permissions. Creating some configuration from scratch. Making my own systemd service definitions. Going back and doing every step again because it failed. &lt;em>Mkay, no thanks, I&amp;rsquo;m out.&lt;/em>&lt;/p>
&lt;p>At least for me it&amp;rsquo;s a plus if it&amp;rsquo;s easy to deploy on Kubernetes since I use it for everything already. I always have a cluster or three laying around so I can get a prototype or five up and running quickly before later spending money for cloud hosting.&lt;/p>
&lt;p>Does the thing have momentum and a community? If it does it probably has high quality tooling either by the vendor or the open source community (preferably both). It probably also has lots of common questions answered on blogs and StackOverflow and Github issues.&lt;/p>
&lt;p>&lt;strong>So we managed to build something and the audience likes it.&lt;/strong>&lt;/p>
&lt;p>How easy is it to move it from a production environment into something stable and low-maintenance? For databases that would typically involve using a managed service for hosting it. You do not want to be responsible for operating your own databases. Is it common enough that there are competitors in the marketplace offering it as a managed service? If there is only a single option expect prices to be very steep. Preferably also a managed service by one of the big known cloud platforms. They are usually cheaper. They are less likely to vanish. It might make integration with other systems easier later.&lt;/p>
&lt;p>&lt;strong>We hit some problems either because of raw scale or some type of usage we did not anticipate in the beginning.&lt;/strong>&lt;/p>
&lt;p>Are there compatible implementations that might solve some common problems? Typically this is because an implementation has to make a decision about it&amp;rsquo;s trade-offs. For a database system this is usually around the CAP theorem. A database system (or anything that keeps state) can be:&lt;/p>
&lt;ul>
&lt;li>&lt;em>Partition Tolerant&lt;/em> - The system still works if a node or the network between nodes fail.&lt;/li>
&lt;li>&lt;em>Available&lt;/em> - All requests receive a response.&lt;/li>
&lt;li>&lt;em>Consistent&lt;/em> - The data we read is the current data and not an earlier state.&lt;/li>
&lt;/ul>
&lt;p>But, you can only have two at the same time. And distributed systems tends to need to be partition tolerant. So we are stuck between consistency and availability.&lt;/p>
&lt;p>It might be a good to have an idea of the CAP tradeoffs an implementation has done, and whether there are compatible implementations with different tradeoffs that can be used if later we find out we need to tweak our trade-offs for speed and/or scale.&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>More information about CAP theorem &lt;a class="link" href="https://en.wikipedia.org/wiki/CAP_theorem" target="_blank" rel="noopener"
>here&lt;/a> and &lt;a class="link" href="https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e" target="_blank" rel="noopener"
>here&lt;/a>. Jepsen have also &lt;a class="link" href="https://jepsen.io/analyses" target="_blank" rel="noopener"
>extensively tested&lt;/a> many popular databases to see how they break and if they are true to their stated trade-offs.&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a id="DatabaseCategories">&lt;/a>&lt;/p>
&lt;h2 id="database-categories">Database categories
&lt;/h2>&lt;p>Databases can be roughly sorted into categories. I&amp;rsquo;ll keep it simple and use the everyday lingo and not go into details about semantics and definitions (forgive me).&lt;/p>
&lt;p>&lt;a class="link" href="https://www.prisma.io/dataguide/intro/comparing-database-types" target="_blank" rel="noopener"
>https://www.prisma.io/dataguide/intro/comparing-database-types&lt;/a>&lt;/p>
&lt;p>&lt;a id="Planning">&lt;/a>&lt;/p>
&lt;h3 id="sql">SQL
&lt;/h3>&lt;p>The oldest category is the relational database, also known as SQL based on the typical interface used to access these databases.&lt;/p>
&lt;p>In general these databases have tables with names, a set of pre-defined columns and an arbitrary number of rows. You should have an idea of the data types to be stored in each column (such as text or numbers).&lt;/p>
&lt;p>The downside of this is that you have to start with a rough model of the data you want to store and work with. The benefit of this is that later you know something about the model of the data you are working with. Most of the time I&amp;rsquo;ll happily do this in the database rather than handle all the potential inconsistencies in all systems that use that database.&lt;/p>
&lt;p>&lt;em>Main contenders: PostgreSQL. MySQL &amp;amp; MariaDB.&lt;/em>&lt;/p>
&lt;p>&lt;a id="NoSQL">&lt;/a>&lt;/p>
&lt;h3 id="nosql">NoSQL
&lt;/h3>&lt;p>All the rage the last decade. You put data in you get data out. The data is structured but not necessarily predefined. Think JSON object with values, arrays and lists.&lt;/p>
&lt;p>The benefit is productivity when developing. The drawback is that you may pay a price for those shortcuts later if you&amp;rsquo;re not careful.&lt;/p>
&lt;p>&lt;em>Main contender: MongoDB.&lt;/em>&lt;/p>
&lt;p>&lt;a id="KeyValue">&lt;/a>&lt;/p>
&lt;h3 id="keyvalue">KeyValue
&lt;/h3>&lt;p>Technically a sub-category of NoSQL, and should probably be called caches. But I feel it deserves it&amp;rsquo;s own category.&lt;/p>
&lt;p>A hyper-fast hyper-simple type of database. It has two columns. A key (ID) and value. The value can be anything, a string, a number, an entire JSON object or a blob containing binary data.&lt;/p>
&lt;p>These are typically used in combination with another type of database. Either by storing very commonly used data for even quicker access. Or for certain types of simple data that requires insane speed or throughput and you don&amp;rsquo;t want to overload the main database.&lt;/p>
&lt;p>&lt;em>Main contender: Redis.&lt;/em>&lt;/p>
&lt;p>&lt;a id="Timeseries">&lt;/a>&lt;/p>
&lt;h3 id="timeseries">Timeseries
&lt;/h3>&lt;p>A lesser known type of database optimized for storing a time series. A time series is a specific data type where the index is typically the time of a measurement. And the measurement is a number.&lt;/p>
&lt;p>A time series is almost never changed after the fact. So these databases can be optimized for writing huge amounts of new data and reading and calculating on existing data. At the cost of performance for deleting or updating old data which is sloooow. Since the values are always numbers that tend to change somewhat predictably compression and deduplication can save us massive amounts of storage.&lt;/p>
&lt;p>&lt;em>Main contenders: Prometheus, InfluxDB, TimescaleDB (plugin for PostgreSQL).&lt;/em>&lt;/p>
&lt;p>&lt;a id="Graph">&lt;/a>&lt;/p>
&lt;h3 id="graph">Graph
&lt;/h3>&lt;p>Graph databases are cool. In a graph database the relationship between objects is a primary feature. Whereas in SQL you need to join an element from one table with another object in another table with some kind of common identifier.&lt;/p>
&lt;p>For most simple use cases a regular SQL database will do fine. But when the number of objects stored (rows) and the number of intermediary tables (joins) become large it gets slow, or expensive, or both.&lt;/p>
&lt;p>I don&amp;rsquo;t have much experience with graph databases but I suspect they are less suited to general tasks and should be reserved for solving specific problems.&lt;/p>
&lt;p>&lt;em>Main contenders: Neo4j. Redis + RedisGraph.&lt;/em>&lt;/p>
&lt;blockquote>
&lt;p>PS: Graph databases and GraphQL are completely separate things.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;a id="OtherNiceThings">&lt;/a>&lt;/p>
&lt;h3 id="other-nice-things">Other nice things
&lt;/h3>&lt;p>When researching this post I&amp;rsquo;ve come across things that look promising but are hard to categorize or fall in their own very niche categories.&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://dgraph.io" target="_blank" rel="noopener"
>Dgraph&lt;/a> - A GraphQL and backend in one.&lt;/li>
&lt;li>&lt;a class="link" href="https://prestodb.io" target="_blank" rel="noopener"
>PrestoDB&lt;/a> - An SQL interface on top of whatever database or storage you want to connect.&lt;/li>
&lt;li>&lt;a class="link" href="https://rethinkdb.com" target="_blank" rel="noopener"
>RethinkDB&lt;/a> - A NoSQL database focused on real-time streaming/updating clients.&lt;/li>
&lt;li>&lt;a class="link" href="https://www.foundationdb.org" target="_blank" rel="noopener"
>FoundationDB&lt;/a> - A transactional key-value store by Apple.&lt;/li>
&lt;li>&lt;a class="link" href="https://clickhouse.tech/" target="_blank" rel="noopener"
>ClickHouse&lt;/a> - An SQL database that stores data (on disk) in columns instead of rows. Makes for blazingly fast analytical and aggregation queries.&lt;/li>
&lt;li>&lt;a class="link" href="https://aws.amazon.com/qldb/" target="_blank" rel="noopener"
>Amazon Quantum Ledger Database&lt;/a> - A managed distributed ledger database (aka blockchain).&lt;/li>
&lt;li>&lt;a class="link" href="https://www.enterprisedb.com/products/edb-postgres-advanced-server-secure-ha-oracle-compatible" target="_blank" rel="noopener"
>EDB Postgres Advanced Server&lt;/a> - An Oracle compatible PostgreSQL variant.&lt;/li>
&lt;/ul>
&lt;p>&lt;a id="Landscape">&lt;/a>&lt;/p>
&lt;h1 id="the-landscape">The Landscape
&lt;/h1>&lt;p>&lt;em>How to use these maps:&lt;/em>&lt;/p>
&lt;p>Version compatibility are in parenthesis. I have not mapped every version and how much breaking they are compared to previous versions but included some notes where I know there might be issues.&lt;/p>
&lt;p>&lt;em>API/Protocol/Interface&lt;/em> - This is decided by the framework, tool or driver you want to use. Sometimes it might be easier to choose the framework first and then a fitting database protocol. Or you might be lucky to choose the database features you need first and then select frameworks, tools and drivers that support it.&lt;/p>
&lt;blockquote>
&lt;p>I think interfaces are really important when creating and choosing technology. I had a &lt;a class="link" href="https://speakerdeck.com/stianovrevage/avoiding-lock-in-without-avoiding-managed-services" target="_blank" rel="noopener"
>presentation&lt;/a> about it a while ago and I think it&amp;rsquo;s still relevant.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;em>Engine&lt;/em> - Database implementations that are independent but try to be compatible. If there are alternatives to the &amp;ldquo;original&amp;rdquo; implementation they might have done different tradeoffs with regards to the CAP theorem or solve other specific problems.&lt;/p>
&lt;p>&lt;em>Big three managed&lt;/em> - Available managed services by the big three clouds, Amazon (AWS), Google (GCP) or Microsoft (Azure). Having an option to host in the big three is most likely the cheapest method as well as having a variety of other managed services to build a complete system in a single cloud.&lt;/p>
&lt;p>&lt;em>Vendor managed&lt;/em> - If the database vendor or backing company offers an Official managed service. They are usually hosted on the big three. Potentially a large cost premium over the raw compute power.&lt;/p>
&lt;p>&lt;em>Self-hosted&lt;/em> - Implementations you can run on your own computer or server.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Legend&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;img src="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/icon-checklist.png"
width="42"
height="48"
srcset="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/icon-checklist_hu1289597614310538750.png 480w, https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/icon-checklist_hu305759868025016403.png 1024w"
loading="lazy"
alt="icon-checklist"
class="gallery-image"
data-flex-grow="87"
data-flex-basis="210px"
>&lt;/td>
&lt;td>The checklist icon marks potential compatibility issues. For most use cases not a problem.&lt;br>&lt;strong>PS:&lt;/strong> The absence of this icon does not automatically mean compatibility.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;img src="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/icon-operator.png"
width="50"
height="50"
srcset="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/icon-operator_hu14757510342261432426.png 480w, https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/icon-operator_hu9633860489137427651.png 1024w"
loading="lazy"
alt="icon-operator"
class="gallery-image"
data-flex-grow="100"
data-flex-basis="240px"
>&lt;/td>
&lt;td>I put the lightning icon on the self-hosted implementations that have what seems to be stable Kubernetes operators available. In short, a Kubernetes operator makes running a stateful system, such as a database, on Kubernetes much easier. It might allow for longer time before migrating to a managed service.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;a id="SQLMap">&lt;/a>&lt;/p>
&lt;h2 id="sql-1">SQL
&lt;/h2>&lt;p>&lt;img src="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-sql.png"
width="1405"
height="947"
srcset="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-sql_hu3071437159255848473.png 480w, https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-sql_hu14104597638369796258.png 1024w"
loading="lazy"
alt="map-sql"
class="gallery-image"
data-flex-grow="148"
data-flex-basis="356px"
>&lt;/p>
&lt;blockquote>
&lt;p>Compatibility:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://blog.yugabyte.com/postgresql-compatibility-in-yugabyte-db-2-0/" target="_blank" rel="noopener"
>PostgreSQL - Yugabyte&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.cockroachlabs.com/docs/stable/postgresql-compatibility.html" target="_blank" rel="noopener"
>PostgreSQL - CockroachDB&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://mariadb.com/kb/en/mariadb-vs-mysql-compatibility/" target="_blank" rel="noopener"
>MySQL - MariaDB&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Kubernetes Operators:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/CrunchyData/postgres-operator" target="_blank" rel="noopener"
>PostgreSQL (CrunchyData)&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/zalando/postgres-operator" target="_blank" rel="noopener"
>PostgreSQL (Zalando)&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://docs.yugabyte.com/latest/deploy/kubernetes/single-zone/oss/yugabyte-operator/" target="_blank" rel="noopener"
>Yugabyte&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/cockroachdb/cockroach-operator" target="_blank" rel="noopener"
>CockroachDB&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.percona.com/software/percona-kubernetes-operators" target="_blank" rel="noopener"
>Percona PostgreSQL for MySQL &amp;amp; XtraDB&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a id="NoSQLMap">&lt;/a>&lt;/p>
&lt;h2 id="nosql-1">NoSQL
&lt;/h2>&lt;p>&lt;img src="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-nosql.png"
width="1404"
height="847"
srcset="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-nosql_hu2273731095068582186.png 480w, https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-nosql_hu12168083053440373248.png 1024w"
loading="lazy"
alt="map-nosql"
class="gallery-image"
data-flex-grow="165"
data-flex-basis="397px"
>&lt;/p>
&lt;blockquote>
&lt;p>PS: There are some &lt;a class="link" href="https://docs.mongodb.com/manual/release-notes/4.0-compatibility/" target="_blank" rel="noopener"
>breaking changes&lt;/a> from MongoDB 3.6 to 4 so make sure the tools you intend to use are compatible with the database version you intend on using.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Kubernetes Operators:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/mongodb/mongodb-kubernetes-operator" target="_blank" rel="noopener"
>MongoDB&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.percona.com/doc/kubernetes-operator-for-psmongodb/index.html" target="_blank" rel="noopener"
>Percona Distribution for MongoDB&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/scylladb/scylla-operator" target="_blank" rel="noopener"
>ScyllaDB&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://www.elastic.co/guide/en/cloud-on-k8s/current/k8s-overview.html" target="_blank" rel="noopener"
>Elastic Stack&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a id="KeyValueMap">&lt;/a>&lt;/p>
&lt;h2 id="keyvalue-1">KeyValue
&lt;/h2>&lt;p>&lt;img src="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-keyvalue.png"
width="513"
height="767"
srcset="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-keyvalue_hu18426603385328126354.png 480w, https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-keyvalue_hu7247583368495670911.png 1024w"
loading="lazy"
alt="map-keyvalue"
class="gallery-image"
data-flex-grow="66"
data-flex-basis="160px"
>&lt;/p>
&lt;blockquote>
&lt;p>Kubernetes Operators:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/spotahome/redis-operator" target="_blank" rel="noopener"
>Redis (Spotahome)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a id="TimeseriesMap">&lt;/a>&lt;/p>
&lt;h2 id="timeseries-1">Timeseries
&lt;/h2>&lt;p>&lt;img src="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-timeseries.png"
width="1724"
height="757"
srcset="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-timeseries_hu2547349071269886546.png 480w, https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-timeseries_hu14200254779532467911.png 1024w"
loading="lazy"
alt="map-timeseries"
class="gallery-image"
data-flex-grow="227"
data-flex-basis="546px"
>&lt;/p>
&lt;blockquote>
&lt;p>Kubernetes Operators:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/prometheus-community/helm-charts/tree/main/charts/kube-prometheus-stack" target="_blank" rel="noopener"
>Prometheus-Stack&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/VictoriaMetrics/operator" target="_blank" rel="noopener"
>VictoriaMetrics&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a id="GraphMap">&lt;/a>&lt;/p>
&lt;h2 id="graph-1">Graph
&lt;/h2>&lt;p>&lt;img src="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-graph.png"
width="1614"
height="761"
srcset="https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-graph_hu18251327852176947982.png 480w, https://blog.stian.omg.lol/p/end-of-2020-rough-database-landscape/map-graph_hu10764438276487603028.png 1024w"
loading="lazy"
alt="map-graph"
class="gallery-image"
data-flex-grow="212"
data-flex-basis="509px"
>&lt;/p>
&lt;blockquote>
&lt;p>Kubernetes Operators:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="https://www.arangodb.com/docs/stable/deployment-kubernetes-usage.html" target="_blank" rel="noopener"
>ArangoDB&lt;/a>&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;a id="FurtherReading">&lt;/a>&lt;/p>
&lt;h1 id="further-reading">Further reading
&lt;/h1>&lt;ul>
&lt;li>&lt;a class="link" href="https://en.wikipedia.org/wiki/Comparison_of_relational_database_management_systems" target="_blank" rel="noopener"
>Wikipedia on RDBMS&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://db-engines.com/en/" target="_blank" rel="noopener"
>DB-engines.com&lt;/a> - Lots of statistics and comparisons between DB engines&lt;/li>
&lt;li>&lt;a class="link" href="https://landscape.cncf.io/" target="_blank" rel="noopener"
>CNCF Landscape&lt;/a> - What&amp;rsquo;s moving in the cloud native landscape, including databases.&lt;/li>
&lt;/ul>
&lt;p>&lt;a id="Conclusion">&lt;/a>&lt;/p>
&lt;h1 id="conclusion">Conclusion
&lt;/h1>&lt;p>Congratulations if you made it this far!&lt;/p>
&lt;p>I did this research primarily to reduce my own analysis paralysis on various projects so I can get-back-to-building. If you learned something as well, great stuff!&lt;/p>
&lt;p>And if you want my advice, just use PostgreSQL unless you really know about some special requirements that necessitates using something else :-)&lt;/p></description></item></channel></rss>